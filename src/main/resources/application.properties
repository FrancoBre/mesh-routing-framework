############################################################
# GENERAL SIMULATION CONFIGURATION
############################################################

# Optional (default=42)
# Seed used for deterministic random number generation.
# Same seed + same config => identical simulation.
seed=42

# Mandatory
# Network topology preset to use.
# Possible values:
#   _6X6_GRID
#   _7_HYPERCUBE              (TODO)
#   _116_NODE_LATA            (TODO)
#   FILE                     (TODO)
topology=_6X6_GRID

# Optional (mandatory if topology=FILE, default=empty)
# External topology file path (used only if topology=FILE).
topology.file=

# Mandatory
# Routing algorithms to evaluate.
# The simulation will be executed once per algorithm (same config, same seed).
# Possible values:
#   SHORTEST_PATH
#   Q_ROUTING
#   Q_ROUTING_FULL_ECHO      (TODO)
algorithms=SHORTEST_PATH,Q_ROUTING

# Optional (default=unlimited)
# Maximum number of packets allowed in flight across the entire network at the same time.
# Acts as backpressure to avoid runaway congestion and memory growth.
# If empty, treat as "no limit".
max-active-packets=1000

# Optional (default=0)
# Number of initial ticks to ignore for measurements/plots (warm-up / transient discard).
warmup-ticks=6000

# Optional (default=auto-generated)
# Used to organize outputs on disk (e.g., folder naming).
experiment-name=

# Optional (default=./results/)
# Base output directory for all generated results.
output-folder=


############################################################
# TERMINATION POLICY
############################################################

# Mandatory
# Defines when the simulation should stop.
# Possible values:
#   FIXED_TICKS              -> stop after a fixed number of ticks
#   TOTAL_PACKETS_DELIVERED  -> stop after N packets are delivered
#   COMPOSITE                -> combine multiple policies with OR/AND
termination-policy=FIXED_TICKS

# Optional (mandatory if termination-policy=COMPOSITE, default=OR)
# Composite policy combination mode:
#   OR  -> stop when ANY policy triggers (recommended for safety caps)
#   AND -> stop only when ALL policies trigger
termination-policy.composite.mode=OR

# Optional (mandatory if termination-policy=COMPOSITE, default=empty)
# Comma-separated list of policies to combine.
# Possible values inside list:
#   FIXED_TICKS
#   TOTAL_PACKETS_DELIVERED
termination-policy.composite.policies=

# Optional (mandatory if FIXED_TICKS is used, default=15000)
termination-policy.fixed-ticks.total-ticks=20000

# Optional (mandatory if TOTAL_PACKETS_DELIVERED is used, default=empty)
termination-policy.packets-delivered.total-packets=


############################################################
# TRAFFIC INJECTION SCHEDULE
# (WHEN and HOW MANY packets are injected per tick)
#
# This section decides the injection "volume over time".
# Pair selection (origin/destination) is configured separately below.
############################################################

# Mandatory
# Injection schedule type.
# Possible values:
#   LOAD_LEVEL                -> average load L per tick (L can be > 1.0)
#   PROB_PER_TICK             -> inject 0/1 packet per tick using Bernoulli(p)
#   GAP                       -> inject batch every N ticks
#   LINEAR_INCREMENTAL        -> (TODO if you keep it) increasing load over time
#   WINDOWED_LOAD             -> multi-phase fixed batch sizes (A/B/C)  (from WindowedLoadConstants)
#   PLATEAU_THEN_LINEAR       -> plateau (gap+batch), then ramp batch size (from PlateauThenLinearConstants)
#   PLATEAU_RAMP_PLATEAU      -> plateau -> ramp -> plateau (from PlateauRampPlateauConstants)
#   FIXED_LOAD_STEP           -> stepwise batch levels every STEP_TICKS (from FixedLoadStepConstants)
injection-schedule=LOAD_LEVEL


# ----------------------------------------------------------
# LOAD_LEVEL (average load L per tick, supports >1.0)
# ----------------------------------------------------------
# Optional (mandatory if injection-schedule=LOAD_LEVEL, default=0.0)
# L in [0..infinity). Implementation commonly does:
# injectCount = floor(L) + Bernoulli(frac(L))
injection-schedule.load-level.L=0.5


# ----------------------------------------------------------
# PROB_PER_TICK (Bernoulli injection)
# ----------------------------------------------------------
# Optional (mandatory if injection-schedule=PROB_PER_TICK, default=0.0)
# Probability in [0..1] to inject exactly 1 packet on a tick.
injection-schedule.prob-per-tick.p=0.0


# ----------------------------------------------------------
# GAP (batch injection every N ticks)
# ----------------------------------------------------------
# Optional (mandatory if injection-schedule=GAP, default=1)
# Inject a batch only every N ticks.
injection-schedule.gap.inject-every-n-ticks=1

# Optional (mandatory if injection-schedule=GAP, default=1)
# Number of packets injected each time the gap triggers.
injection-schedule.gap.batch-size=1


# ----------------------------------------------------------
# WINDOWED_LOAD (from WindowedLoadConstants)
# Concept: fixed phases by time with fixed batch size per tick.
# Phase A runs first, then Phase B, then Phase C continues forever.
# Phase C batch-size may be 0 to stop injecting after A+B.
# ----------------------------------------------------------
# Optional (mandatory if injection-schedule=WINDOWED_LOAD, default=200)
injection-schedule.windowed-load.phase-a.ticks=200
# Optional (mandatory if injection-schedule=WINDOWED_LOAD, default=2)
injection-schedule.windowed-load.phase-a.batch=2

# Optional (mandatory if injection-schedule=WINDOWED_LOAD, default=800)
injection-schedule.windowed-load.phase-b.ticks=800
# Optional (mandatory if injection-schedule=WINDOWED_LOAD, default=10)
injection-schedule.windowed-load.phase-b.batch=10

# Optional (mandatory if injection-schedule=WINDOWED_LOAD, default=0)
# Batch after phases (0 means stop injecting after A+B).
injection-schedule.windowed-load.phase-c.batch=0


# ----------------------------------------------------------
# PLATEAU_THEN_LINEAR (from PlateauThenLinearConstants)
# Concept:
# - Plateau: every K ticks inject a fixed batch size (constant load).
# - Ramp: inject more frequently (often every tick) and increase batch size by +1
#         every X ticks.
# ----------------------------------------------------------
# Optional (mandatory if injection-schedule=PLATEAU_THEN_LINEAR, default=200)
injection-schedule.plateau-then-linear.plateau.ticks=200
# Optional (mandatory if injection-schedule=PLATEAU_THEN_LINEAR, default=5)
injection-schedule.plateau-then-linear.plateau.inject-every-n-ticks=5
# Optional (mandatory if injection-schedule=PLATEAU_THEN_LINEAR, default=2)
injection-schedule.plateau-then-linear.plateau.batch-size=2

# Optional (mandatory if injection-schedule=PLATEAU_THEN_LINEAR, default=1)
injection-schedule.plateau-then-linear.ramp.inject-every-n-ticks=1
# Optional (mandatory if injection-schedule=PLATEAU_THEN_LINEAR, default=2)
injection-schedule.plateau-then-linear.ramp.start-batch-size=2
# Optional (mandatory if injection-schedule=PLATEAU_THEN_LINEAR, default=200)
injection-schedule.plateau-then-linear.ramp.increase-every-n-ticks=200


# ----------------------------------------------------------
# PLATEAU_RAMP_PLATEAU (from PlateauRampPlateauConstants)
# Concept:
# - Phase 1 plateau: constant batch injection with gaps
# - Phase 2 ramp: increase batch size over time until duration or max batch
# - Phase 3 plateau: sustained high load
# ----------------------------------------------------------
# Phase 1 plateau
# Optional (mandatory if injection-schedule=PLATEAU_RAMP_PLATEAU, default=200)
injection-schedule.plateau-ramp-plateau.p1.ticks=200
# Optional (mandatory if injection-schedule=PLATEAU_RAMP_PLATEAU, default=5)
injection-schedule.plateau-ramp-plateau.p1.inject-every-n-ticks=5
# Optional (mandatory if injection-schedule=PLATEAU_RAMP_PLATEAU, default=2)
injection-schedule.plateau-ramp-plateau.p1.batch-size=2

# Ramp
# Optional (mandatory if injection-schedule=PLATEAU_RAMP_PLATEAU, default=1)
injection-schedule.plateau-ramp-plateau.ramp.inject-every-n-ticks=1
# Optional (mandatory if injection-schedule=PLATEAU_RAMP_PLATEAU, default=2)
injection-schedule.plateau-ramp-plateau.ramp.start-batch-size=2
# Optional (mandatory if injection-schedule=PLATEAU_RAMP_PLATEAU, default=200)
injection-schedule.plateau-ramp-plateau.ramp.increase-every-n-ticks=200
# Optional (mandatory if injection-schedule=PLATEAU_RAMP_PLATEAU, default=600)
injection-schedule.plateau-ramp-plateau.ramp.ticks=600
# Optional (mandatory if injection-schedule=PLATEAU_RAMP_PLATEAU, default=10)
injection-schedule.plateau-ramp-plateau.ramp.max-batch-size=10

# Phase 3 plateau
# Optional (mandatory if injection-schedule=PLATEAU_RAMP_PLATEAU, default=1)
injection-schedule.plateau-ramp-plateau.p3.inject-every-n-ticks=1
# Optional (mandatory if injection-schedule=PLATEAU_RAMP_PLATEAU, default=10)
injection-schedule.plateau-ramp-plateau.p3.batch-size=10


# ----------------------------------------------------------
# FIXED_LOAD_STEP (from FixedLoadStepConstants)
# Concept:
# - Every STEP_TICKS, switch to the next batch size level.
# - Injection occurs every N ticks.
# - Batch sizes can be explicit list (recommended) or a simple range (optional).
# ----------------------------------------------------------
# Optional (mandatory if injection-schedule=FIXED_LOAD_STEP, default=200)
injection-schedule.fixed-load-step.step-ticks=200

# Optional (mandatory if injection-schedule=FIXED_LOAD_STEP, default=1)
injection-schedule.fixed-load-step.inject-every-n-ticks=1

# Optional (mandatory if injection-schedule=FIXED_LOAD_STEP, default=1,2,3,4,5,6,7)
# Comma-separated list of batch sizes (load levels).
injection-schedule.fixed-load-step.batch-sizes=1,2,3,4,5,6,7

# Optional (alternative to batch-sizes, default=empty)
# If you prefer a simple generated range instead of explicit levels,
# you can implement START_BATCH..MAX_BATCH and leave batch-sizes empty.
# injection-schedule.fixed-load-step.start-batch=1
# injection-schedule.fixed-load-step.max-batch=10


############################################################
# PACKET PAIR SELECTION
# (WHERE packets originate and where they go)
#
# This section decides the origin/destination selection policy.
############################################################

# Mandatory
# Pair selection strategy.
# Possible values:
#   RANDOM                       -> pick origin/destination uniformly at random
#   RANDOM_IN_GROUPS             -> pick origin from a group, destination from another group
#   OSCILLATING_BETWEEN_GROUPS   -> alternate direction between two groups over time
#   OSCILLATING_GRID_AXIS        -> top<->bottom or left<->right (TODO if you implement it)
pair-selection=RANDOM

# Optional (default=200)
# Only used by oscillating pair selectors.
# Number of ticks before switching direction.
pair-selection.oscillating.period-ticks=200

# Optional (default=true)
# Disallow origin == destination.
pair-selection.constraints.disallow-self=true

# Optional (default=true)
# Disallow destination being a direct neighbor of origin.
# Useful to avoid trivial one-hop routes in grid experiments.
pair-selection.constraints.disallow-neighbor=true


############################################################
# GROUP DEFINITIONS (OPTIONAL)
# Used by subset-based pair selection strategies.
############################################################

# Optional (default=empty)
# Comma-separated list of named groups.
# Example values: TOP,BOTTOM,LEFT,RIGHT,CENTER
groups=TOP,BOTTOM

# Optional (mandatory if group name is referenced, default=empty)
# Group defined explicitly by node IDs (comma-separated).
groups.TOP.nodes=0,1,2,3,4,5
groups.BOTTOM.nodes=30,31,32,33,34,35


############################################################
# NETWORK DYNAMICS
# (Changes applied to the network during the simulation)
############################################################

# Optional (default=NONE)
# Possible values:
#   NONE
#   NODE_FAILURES               (TODO or WIP)
#   LINK_FAILURES               (TODO)
#   MOBILITY                    (TODO)
network-dynamics=NONE

# Optional (mandatory if network-dynamics=NODE_FAILURES, default=RANDOM)
# Failure model.
# Possible values:
#   RANDOM
#   SCHEDULED                   (TODO)
network-dynamics.node-failures.model=RANDOM

# Optional (mandatory if network-dynamics=NODE_FAILURES, default=0.001)
# Probability per tick that a node fails.
network-dynamics.node-failures.random.p=0.001

# Optional (mandatory if network-dynamics=NODE_FAILURES, default=500)
# Average downtime in ticks.
network-dynamics.node-failures.random.mean-downtime-ticks=500

# Optional (mandatory if network-dynamics=NODE_FAILURES, default=2000)
# Average uptime in ticks before next failure.
network-dynamics.node-failures.random.mean-uptime-ticks=2000


############################################################
# METRICS (NUMERICAL MEASUREMENTS)
############################################################

# Mandatory
# Metrics collected during the simulation.
# Possible values:
#   AVG_DELIVERY_TIME
#   P95_DELIVERY_TIME           (TODO)
#   PACKETS_IN_FLIGHT           (TODO)
#   QUEUE_LENGTH                (TODO)
metrics=AVG_DELIVERY_TIME


############################################################
# OUTPUTS / VISUALIZATIONS
############################################################

# Optional (default=empty)
# Outputs generated from collected data.
# Possible values:
#   HEAT_MAP
#   GIF_ROUTE
outputs=HEAT_MAP,CONFIG_DUMP

# Optional (default=1)
# Sampling frequency (in ticks) for visualization outputs.
# Example: 1 = every tick, 10 = every 10 ticks.
output.sample-every-ticks=10
